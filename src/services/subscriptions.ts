import { db } from '../config/firebase';
import { 
  collection, 
  addDoc, 
  doc, 
  updateDoc, 
  getDocs, 
  getDoc,
  query, 
  where, 
  orderBy,
  deleteDoc,
  Timestamp
} from 'firebase/firestore';

export interface SubscriptionPlan {
  id?: string;
  name: string;
  description: string;
  frequency: 'weekly' | 'biweekly' | 'monthly' | 'quarterly' | 'semi-annual' | 'one-time';
  services: string[];
  basePrice: number;
  isActive: boolean;
  estimatedDuration: number; // in minutes
  requiredSkills?: string[];
  seasonalAdjustments?: {
    spring: number;
    summer: number;
    fall: number;
    winter: number;
  };
  customizations?: {
    allowPriceOverride: boolean;
    allowServiceModification: boolean;
    allowFrequencyChange: boolean;
  };
  createdAt?: number;
  updatedAt?: number;
  createdBy?: string;
}

export interface ClientSubscription {
  id?: string;
  clientId: string;
  subscriptionPlanId: string;
  status: 'active' | 'paused' | 'cancelled' | 'expired';
  customPrice?: number;
  customServices?: string[];
  customFrequency?: 'weekly' | 'biweekly' | 'monthly' | 'quarterly' | 'semi-annual';
  startDate: number;
  endDate?: number;
  nextJobDate: number;
  lastJobDate?: number;
  preferredDayOfWeek?: number; // 0-6 (Sunday-Saturday)
  preferredTimeSlot?: 'morning' | 'afternoon' | 'evening';
  specialInstructions?: string;
  assignedWorkerId?: string;
  totalJobsCompleted: number;
  totalAmount: number;
  autoRenewal: boolean;
  paymentStatus: 'current' | 'overdue' | 'failed';
  createdAt?: number;
  updatedAt?: number;
  createdBy?: string;
}

export interface SubscriptionJob {
  id?: string;
  subscriptionId: string;
  clientId: string;
  jobId: string;
  scheduledDate: number;
  status: 'scheduled' | 'confirmed' | 'completed' | 'cancelled' | 'rescheduled';
  isAutoGenerated: boolean;
  generatedAt: number;
  sequence: number;
  notes?: string;
  rescheduledFrom?: number;
  rescheduledReason?: string;
}

// Subscription Plan Management
export async function createSubscriptionPlan(plan: SubscriptionPlan, adminId: string): Promise<string> {
  const ref = await addDoc(collection(db, 'subscription_plans'), {
    ...plan,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    createdBy: adminId
  });
  return ref.id;
}

export async function updateSubscriptionPlan(planId: string, updates: Partial<SubscriptionPlan>): Promise<void> {
  const ref = doc(db, 'subscription_plans', planId);
  await updateDoc(ref, {
    ...updates,
    updatedAt: Date.now()
  });
}

export async function getSubscriptionPlans(activeOnly = false): Promise<SubscriptionPlan[]> {
  try {
    let q = query(collection(db, 'subscription_plans'), orderBy('createdAt', 'desc'));
    
    if (activeOnly) {
      q = query(collection(db, 'subscription_plans'), 
        where('isActive', '==', true), 
        orderBy('createdAt', 'desc')
      );
    }
    
    const snap = await getDocs(q);
    return snap.docs.map(d => ({ id: d.id, ...d.data() })) as SubscriptionPlan[];
  } catch (error) {
    console.error('Error fetching subscription plans:', error);
    return [];
  }
}

export async function getSubscriptionPlan(planId: string): Promise<SubscriptionPlan | null> {
  try {
    const snap = await getDoc(doc(db, 'subscription_plans', planId));
    if (snap.exists()) {
      return { id: snap.id, ...snap.data() } as SubscriptionPlan;
    }
    return null;
  } catch (error) {
    console.error('Error fetching subscription plan:', error);
    return null;
  }
}

export async function deleteSubscriptionPlan(planId: string): Promise<void> {
  await deleteDoc(doc(db, 'subscription_plans', planId));
}

// Client Subscription Management
export async function createClientSubscription(subscription: ClientSubscription, createdBy: string): Promise<string> {
  const ref = await addDoc(collection(db, 'client_subscriptions'), {
    ...subscription,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    createdBy
  });
  return ref.id;
}

export async function updateClientSubscription(subscriptionId: string, updates: Partial<ClientSubscription>): Promise<void> {
  const ref = doc(db, 'client_subscriptions', subscriptionId);
  await updateDoc(ref, {
    ...updates,
    updatedAt: Date.now()
  });
}

export async function getClientSubscriptions(clientId?: string): Promise<ClientSubscription[]> {
  try {
    let q = query(collection(db, 'client_subscriptions'), orderBy('createdAt', 'desc'));
    
    if (clientId) {
      q = query(collection(db, 'client_subscriptions'), 
        where('clientId', '==', clientId),
        orderBy('createdAt', 'desc')
      );
    }
    
    const snap = await getDocs(q);
    return snap.docs.map(d => ({ id: d.id, ...d.data() })) as ClientSubscription[];
  } catch (error) {
    console.error('Error fetching client subscriptions:', error);
    return [];
  }
}

export async function getActiveSubscriptions(): Promise<ClientSubscription[]> {
  try {
    const q = query(
      collection(db, 'client_subscriptions'),
      where('status', '==', 'active'),
      orderBy('nextJobDate', 'asc')
    );
    const snap = await getDocs(q);
    return snap.docs.map(d => ({ id: d.id, ...d.data() })) as ClientSubscription[];
  } catch (error) {
    console.error('Error fetching active subscriptions:', error);
    return [];
  }
}

export async function getUpcomingJobs(daysAhead = 7): Promise<ClientSubscription[]> {
  try {
    const futureDate = Date.now() + (daysAhead * 24 * 60 * 60 * 1000);
    const q = query(
      collection(db, 'client_subscriptions'),
      where('status', '==', 'active'),
      where('nextJobDate', '<=', futureDate),
      orderBy('nextJobDate', 'asc')
    );
    const snap = await getDocs(q);
    return snap.docs.map(d => ({ id: d.id, ...d.data() })) as ClientSubscription[];
  } catch (error) {
    console.error('Error fetching upcoming jobs:', error);
    return [];
  }
}

// Subscription Job Management
export async function createSubscriptionJob(subJob: SubscriptionJob): Promise<string> {
  const ref = await addDoc(collection(db, 'subscription_jobs'), {
    ...subJob,
    generatedAt: Date.now()
  });
  return ref.id;
}

export async function getSubscriptionJobs(subscriptionId?: string): Promise<SubscriptionJob[]> {
  try {
    let q = query(collection(db, 'subscription_jobs'), orderBy('scheduledDate', 'desc'));
    
    if (subscriptionId) {
      q = query(collection(db, 'subscription_jobs'),
        where('subscriptionId', '==', subscriptionId),
        orderBy('scheduledDate', 'desc')
      );
    }
    
    const snap = await getDocs(q);
    return snap.docs.map(d => ({ id: d.id, ...d.data() })) as SubscriptionJob[];
  } catch (error) {
    console.error('Error fetching subscription jobs:', error);
    return [];
  }
}

// Utility functions
export function calculateNextJobDate(subscription: ClientSubscription, plan?: SubscriptionPlan): number {
  const frequency = subscription.customFrequency || plan?.frequency || 'weekly';
  
  // If it's a one-time service, there's no next date
  if (frequency === 'one-time') {
    return subscription.startDate; // No next date for one-time
  }
  
  const startDate = subscription.lastJobDate || subscription.startDate;
  const date = new Date(startDate);
  
  switch (frequency) {
    case 'weekly':
      date.setDate(date.getDate() + 7);
      break;
    case 'biweekly':
      date.setDate(date.getDate() + 14);
      break;
    case 'monthly':
      date.setMonth(date.getMonth() + 1);
      break;
    case 'quarterly':
      date.setMonth(date.getMonth() + 3);
      break;
    case 'semi-annual':
      date.setMonth(date.getMonth() + 6);
      break;
    default:
      date.setDate(date.getDate() + 7); // Default to weekly
  }
  
  // Apply preferred day of week if specified
  if (subscription.preferredDayOfWeek !== undefined) {
    const dayDiff = subscription.preferredDayOfWeek - date.getDay();
    if (dayDiff !== 0) {
      date.setDate(date.getDate() + (dayDiff > 0 ? dayDiff : dayDiff + 7));
    }
  }
  
  return date.getTime();
}

export function getSeasonalPrice(basePrice: number, seasonalAdjustments?: SubscriptionPlan['seasonalAdjustments']): number {
  if (!seasonalAdjustments) return basePrice;
  
  const month = new Date().getMonth();
  let multiplier = 1;
  
  if (month >= 2 && month <= 4) { // Spring (Mar-May)
    multiplier = seasonalAdjustments.spring;
  } else if (month >= 5 && month <= 7) { // Summer (Jun-Aug)
    multiplier = seasonalAdjustments.summer;
  } else if (month >= 8 && month <= 10) { // Fall (Sep-Nov)
    multiplier = seasonalAdjustments.fall;
  } else { // Winter (Dec-Feb)
    multiplier = seasonalAdjustments.winter;
  }
  
  return basePrice * multiplier;
}